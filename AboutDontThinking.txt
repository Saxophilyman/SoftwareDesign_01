Удивительные вещи, связаны с нюансами программирования 
ПО мотивам материалов из курса.

Казалось бы простая  вещь вычислить среднее для списка значений некоторого типа T.

С какими проблемами здесь можно столькнуться?
- T оригинальный или просто пользовательский тип, к которому стандартная арифметика неприменима
- что если список пуст
- входной список может быть бесконечным (в Java их легко получить (Stream.generate, iterate)

Мы стремимся уйти от обработки исключений, которая ничего нам не даст

Иногда конечно более информативная ошибка времени лучше, чем ничего

Возможным решением будет разработка и соблюдение предусловий
1. конечно же проверку на пустоту списка
2. можем записать требование конечности списка/мы можем уточнить требование к типу списка, чтобы он поддерживал интерфейс IEnumerable (который формально конечен)
3. лучше всего определить свой тип (коллекцию, которая заведомо не пуста)

Как нам сконструировать такой тип, в котором гарантированно будет хотя бы один элемент
паттерн Guard Clause
Мы сразу проверяем, что входные данные удовлетворяют предварительным условиям, и если нет, сразу завершаем работу. 
Например, мы можем задать в конструкторе обязательный первый элемент коллекции
Но может возникнуть размазанная по проекту валидация
но что если он сам придёт как null?

На помощь приходит система типов.
Приём, как type parsing: "ввод" слабого типа в значение более сильного типа, который гарантирует, что "валидация" прошла успешно (как булевский флаг).

Кажется, что мы просто заменили одно исключение другим, но дело не в этом, это технический момент. 
Дело в том, что мы заменили несистематизированный и размазанный по проекту код проверки (классический "аспект" из AOP) одним тестовым шагом.

Ещё один аспект
при вызове конструктора непустого списка имеется сигнатура foo(T FirstItem)
Как мы можем защитить нашу непустую коллекцию, не выбрасывая исключений, даже если в качестве FirtsItem передан таки null
Можно сделать конструктор приватным, а вместо него создать статический фабричный метод, возвращающий значение в виде условной монады Maybe или Either

Резюме. Инкапсуляция занимает центральное место в ООП: объект сам ответственен за защиту своих инвариантов. В статически типизированных языках объекты -- это экземпляры классов. Классы -- это типы. Типы инкапсулируют инварианты; они несут в себе гарантии.

Вместо того, чтобы выполнять ручную проверку входных аргументов во время выполнения, вы можете объявить конструкторы и методы таким образом, чтобы они принимали только те аргументы, которые гарантированно допустимы.
Это один из хороших способов уменьшить количество исключений, которые выбрасывает ваш код.

Адекватная обработка исключения эквивалентна монаде Either, которая подразумевает два дальнейших "пути" вычислений: Right -- правильный результат (явная мнемоника!), и Left -- ошибка.

Исключения будут допустимы, когда мы можем осознанно продумать крайние случаи и явно классифицировать потенциальные ошибки.
Выбрасывайте исключения в тех ситуациях, из которых, как вы ожидаете, большинство функций не смогут выбраться. Возвращайте Left (ошибочные случаи) в тех ситуациях, которые, как вы ожидаете, захочет обработать типичный "клиент" вашего кода.
Иногда нужны и исключения



строковые шаблоны — это не «магические константы», а куски поведения (мини-язык), и вырывать их далеко от места использования часто вредно.
Лучше шаблон ближе к использованию или «обернуть в функцию с параметрами».
Добавляем типобезопасные фасады, явные локали/валюту, i18n-обёртки, валидацию плейсхолдеров и, при необходимости, версионирование конфигурируемых шаблонов

Снижение Цикломатической сложности
Рабочие способы снижения ЦС - вынос ветвей в полиморфизм (ad-hoc/подтипов), табличная логика, отказ от else в пользу guard-clause(сразу возвращать return)
Идея оборачивать шаблоны/поведение в функции/типы

 Совет AI по материалам
Практические советы по стилю (и ЦС)
Начинай с guard-clauses (убираем else, выпрямляем «ствол» метода), затем спрашивай себя: «Это map/filter/anyMatch/allMatch/collect?» — часто цикл исчезает сам.
Заменяй «проволочный» цикл на алгоритм:
 поиск → anyMatch/findFirst/min/max;
 агрегаты → summarizingInt/reducing/teeing;
 перестановки → sorted/partitioningBy/groupingBy.
Предикат/преобразование — параметром. Тогда функция становится общей, а «ветвления» уезжают в передаваемые лямбды.
Проверяй читаемость. Длинные цепочки Stream лучше разбивать на именованные шаги — это снижает когнитивную сложность, даже если цикломатическая уже мала.
Ассоциативность! Для reduce важно, чтобы операция была ассоциативной (иначе параллельные потоки дадут сюрпризы). Для мутабельных контейнеров — collect.
Никаких циклов, если их можно заменить подходящей абстракцией.
