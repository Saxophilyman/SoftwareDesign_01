// По предыдущему заданию:
// Крутой способ вывести синхронизацию отдельно на метод.

// В реальных проектах логика параллельной работы во много раз сложнее, 
// поэтому и выявлять баги существенно труднее, и тесты не особо помогают, 
// так как часто невозможно смоделировать конкретные ситуации, завязанные на микро(милли)секундные шаги.
// И иногда возникает вопрос действительно использование многопоточности так необходимо?
// Воспринимается всегда круто, но хотя бы с линейным разобраться..

// synchronized, ReentrantLock, Semaphores, Read-Write Locks, Barriers, CompletableFuture, Atomics, ExecutorService, CountDownLatch, Реактивные потоки
// Выглядит ошеломляюще, с большинством из них знакомился и приятно удивлён, что запомнил их концепции. 
// На практике довольно трудно придумать что-то с чем ты не сталкивался и имеешь в целом смутное представление. Без AI мне подобные задачи с преиензией на оригинальность на данный момент кажутся невозможными
// Я взял около 50 примеров с использованием многопоточных механизмов и выбрал из них 5 наиболее интересных на мой взгляд, с тем условией, чтобы они были и для меня понятны, а не просто копипаста. и построчно разобраны
//---------------------------
